#include "cache.h"
#include <cassert>

#define EXTRACT_PAGE_ID(addr) ((addr) >> LOG2_PAGE_SIZE)            /* Extract the page ID */
#define EXTRACT_BLOCK_ID(addr) (((addr) >> LOG2_BLOCK_SIZE) & 0x3f) /* Extract the block ID within the page */

/* Minimum and maximum value of the block IDs */
#define BLOCK_ID_MIN 0
#define BLOCK_ID_MAX ((PAGE_SIZE / BLOCK_SIZE) - 1)

#define LOG2_L2C_INDEX 10

#define RR_TABLE_ENTRIES 256 // DO NOT FORGET TO UPDATE LOG2 MACRO!
#define LOG2_RR_TABLE 8
#define ROUNDMAX 100
#define SCOREMAX 31
#define BADSCORE 1

typedef struct RR_ENTRY {uint64_t tag; uint8_t valid; } RR_ENTRY;

RR_ENTRY RR_TABLE[RR_TABLE_ENTRIES];
uint64_t best_offset = 0;
uint64_t offset_table[26] = {1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60}; // 26 entries < 64. Taken from paper. Numbers whose prime factorization does not contain primes greater than 5.
uint64_t offset_scores[26];

uint64_t round_counter = 0;

uint64_t get_index(uint64_t addr) {
  uint64_t line_addr = addr >> LOG2_BLOCK_SIZE;
  uint64_t mask = (1LU << LOG2_RR_TABLE) - 1;
  uint64_t low = line_addr & mask;
  uint64_t next = (line_addr >> LOG2_RR_TABLE) & mask;
  return low ^ next;
}

uint64_t get_tag(uint64_t addr) {
  return ((1LU << 19) - 1) & (addr >> (LOG2_BLOCK_SIZE + LOG2_L2C_INDEX));
}
void insert_entry(uint64_t addr) {
  uint64_t page_id = EXTRACT_PAGE_ID(addr);
  uint64_t index = get_index(addr);

  assert(index < RR_TABLE_ENTRIES);

  // prepare entry (use MSB as valid bit)
  // get the tag bits
  uint64_t tag = get_tag(addr); // 19 bits tag, 10 bits set index, 6 bits offset
  assert(tag <= pow(2, 19));
  printf("TAG: %d\n", tag);
  RR_TABLE[index] = RR_ENTRY {tag, 1};
}

// check if entry exist in a table by indexing and matching tag. CHECK FOR VALID BIT ALSO
bool has_entry(uint64_t addr) {
  uint64_t index = get_index(addr);

  if (RR_TABLE[index].valid != 1)
    return false;

  return RR_TABLE[index].tag == get_tag(addr) ? true : false;
}

void run_round(uint64_t addr) {
  round_counter++;
  for (int i = 0; i < 26; i++) {
    // check if entry exist and X - di is in same page
    if (has_entry(addr - offset_table[i]) && EXTRACT_PAGE_ID(addr) == EXTRACT_PAGE_ID(addr - offset_table[i]))
      offset_scores[i]++;
  }
}

uint64_t get_max_score() {
  uint64_t max = offset_scores[0];
  for (int i = 1; i < 26; i++) {
    if (offset_scores[i] > max)
      max = offset_scores[i];
  }
  return max;
}

uint64_t get_best_offset() {
  uint64_t max = 0;
  for (int i = 1; i < 26; i++) {
    if (offset_scores[i] > offset_scores[max])
      max = i;
  }
  return offset_table[max];
}

void reset_phase() {
  for (int i = 0; i < 26; i++)
    offset_scores[i] = 0;
  round_counter = 0;

  // make every entry invalid in the table
  for (int i = 0; i < RR_TABLE_ENTRIES; i++)
    RR_TABLE[i].valid = 0; 
}

void CACHE::l2c_prefetcher_initialize()
{
  cout << "CPU " << cpu << " Region based L2 offset prefetcher" << endl;
  best_offset = 0;
}

// called on every cache access
uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in, uint8_t critical_ip_flag)
{
  // Prefetch X + D if it is in the same page and MSHR is not full.
  // Run the round.
  // Check if any of two requirement are met 1> MAXSCORE 2> MAXROUND. If so then, Reset everything and update the best offset
  // on cache miss and prefetch hit (TODO: how to know if it is a prefetch hit?)
  if (cache_hit == 0) {
    if (MSHR.occupancy < (MSHR.SIZE>>1) && EXTRACT_PAGE_ID(addr) == EXTRACT_PAGE_ID(addr + best_offset) && get_max_score() > BADSCORE) {
      prefetch_line(ip, addr, addr + best_offset, FILL_L2, 0);
    } else if (EXTRACT_PAGE_ID(addr) == EXTRACT_PAGE_ID(addr + best_offset) && get_max_score() > BADSCORE) {
      prefetch_line(ip, addr, addr + best_offset, FILL_LLC, 0);
    }

    // run the round
    run_round(addr);

    if (round_counter == ROUNDMAX || get_max_score() == SCOREMAX) {
      // Phase is done. Reset everything and update best_offset
      best_offset = get_best_offset();
      reset_phase();
    }
  }
  return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t match, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
  // insert base address of prefetched block. (if X is brought then store X - D)
  insert_entry(addr - best_offset);
  return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats()
{
    cout << "CPU " << cpu << " L2C Best Offset prefetcher final stats" << endl;
}
