#include<unordered_set>
#include "cache.h"

#define RR_TABLE_SIZE 256
#define LOG2_RR_TABLE_SIZE 8
#define BADSCORE 1
#define MAXSCORE 31
#define MAXROUND 100
#define OFFSET_COUNT 26

#define LINE_ADDR(addr) ((addr) >> LOG2_BLOCK_SIZE)
#define TAG(addr) ((addr) >> (LOG2_BLOCK_SIZE + 2 * LOG2_RR_TABLE_SIZE))
#define PAGE(addr) ((addr) >> LOG2_PAGE_SIZE)

unordered_set<uint64_t> prefetched_addrs;

typedef struct {
  uint64_t tag;
  bool valid;
} rr_entry;

typedef struct {
  uint8_t round_counter;
  uint8_t max_score;
  uint8_t prev_best_score;
  uint8_t best_offset;
  uint8_t max_offset_index;
  uint8_t current_offset;
  uint8_t offsets[OFFSET_COUNT] = {1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60};
  uint8_t scores[OFFSET_COUNT];
} rr_state;

rr_entry rr_table[RR_TABLE_SIZE];
rr_state state;

void CACHE::l2c_prefetcher_initialize()
{
  cout << "CPU " << cpu << " Region based L2 offset prefetcher" << endl;
  for (int i = 0; i < OFFSET_COUNT; i++)
    state.scores[i] = 0;
  state.round_counter = 0;
  state.current_offset = 0;
  state.prev_best_score = 0;
  state.max_score = 0;
  state.max_offset_index = 0;
  state.best_offset = 0;
}

// called on every cache access
uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in, uint8_t critical_ip_flag)
{
  // lookup the RR table in case of cache miss or prefetch hit
  uint64_t line_addr = LINE_ADDR(addr);
  // prefetch X + D if prev best score is > SCOREBAD
  uint64_t prefetch_addr = (line_addr + state.best_offset) << LOG2_BLOCK_SIZE;
  if (cache_hit == 0 || prefetched_addrs.find(line_addr) != prefetched_addrs.end()) {
    prefetched_addrs.erase(line_addr);
    // check if X - di is in table
    uint64_t test_addr = (line_addr - state.current_offset) << LOG2_BLOCK_SIZE;
    uint64_t test_tag = TAG(test_addr);
    uint64_t test_line = LINE_ADDR(test_addr);
    uint64_t lower = test_line & ((1UL << LOG2_RR_TABLE_SIZE)- 1);
    uint64_t upper = (test_line >> LOG2_RR_TABLE_SIZE) & ((1UL << LOG2_RR_TABLE_SIZE)- 1);
    uint64_t index = lower ^ upper;

    assert(index < RR_TABLE_SIZE);

    if (PAGE(addr) == PAGE(test_addr)) {
      // check if X - di exist in the table
      if (rr_table[index].tag == test_tag && rr_table[index].valid) {
        // increment the current offset and update max_score
        state.scores[state.current_offset]++;
        if (state.scores[state.current_offset] > state.max_score) {
          state.max_score = state.scores[state.current_offset];
          state.max_offset_index = state.current_offset;
        }
      }
      state.current_offset++;
      if (state.current_offset >= OFFSET_COUNT) {
        state.round_counter++;
        state.current_offset = 0;
      }
    }

    // check if we have reached maxscore or roundmax
    if (state.max_score == MAXSCORE || state.round_counter == MAXROUND) {
      // learning phase if over update the best offset
      state.best_offset = state.offsets[state.max_offset_index];

      // reset scores
      for (int i = 0; i < OFFSET_COUNT; i++)
        state.scores[i] = 0;
      state.round_counter = 0;
      state.current_offset = 0;
      state.prev_best_score = state.max_score;
      state.max_score = 0;
      state.max_offset_index = 0;
    }
    if (PAGE(addr) == PAGE(prefetch_addr) && state.prev_best_score > BADSCORE) {
      prefetch_line(ip, addr, prefetch_addr, FILL_L2, metadata_in);
    }
  }
  return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t match, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
  uint64_t line_addr = LINE_ADDR(addr);
  uint64_t page = PAGE(addr);

  // compute table index
  uint64_t lower = line_addr & ((1UL << LOG2_RR_TABLE_SIZE)- 1);
  uint64_t upper = (line_addr >> LOG2_RR_TABLE_SIZE) & ((1UL << LOG2_RR_TABLE_SIZE)- 1);
  uint64_t index = lower ^ upper;
  // if it is a prefetched block then we store X - D. X otherwise
  uint64_t entry;
  if (prefetch == 1) {
    // make metadata_in = 1 if the block is prefetched
    entry = line_addr - state.best_offset;
    entry = entry << LOG2_BLOCK_SIZE;
    prefetched_addrs.insert(LINE_ADDR(entry));
  } else {
    entry = line_addr << LOG2_BLOCK_SIZE;
  }

  // insert in the table if blocks are in a same page
  if (PAGE(addr) == PAGE(entry)) {
    rr_table[index].tag = TAG(entry);
    rr_table[index].valid = 1;
  }
  return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats()
{
}
