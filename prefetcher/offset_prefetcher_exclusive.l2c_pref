#include "cache.h"
#include "set.h"
#include "ooo_cpu.h"
#include "uncore.h"

#define TRACKED_OFFSET_COUNT 5
#define TABLE_ENTRIES 128

typedef struct offset_list {
  int64_t offset;
  uint64_t frequency;
  uint64_t valid;
} offset_list;

typedef struct PAGE_TRACKER {
  uint64_t page_id;
  uint64_t last_cl_addr;
  offset_list tracked_offsets[TRACKED_OFFSET_COUNT]; 
  uint64_t lru;

} PAGE_TRACKER;

PAGE_TRACKER table[TABLE_ENTRIES];
uint64_t old_pf_issued, old_pf_useful;
uint64_t access_counter = 0;
double accuracy;
void CACHE::l2c_prefetcher_initialize() 
{
    cout << "CPU " << cpu << " Region based L2 offset prefetcher" << endl;
    for (int i=0; i<TABLE_ENTRIES; i++)
        table[i].lru = i;
    
    old_pf_issued = old_pf_useful = 0;
}

uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in, uint8_t critical_ip_flag)
{
  uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;
  uint64_t page_addr = addr >> LOG2_PAGE_SIZE;

  // check for table hit
  int index = -1;
  for (int i = 0; i < TABLE_ENTRIES; i++) {
    if (table[i].page_id == page_addr) {
      index = i;
      break;
    }
  }

  // this is a new page id, allocate a new entry
  if (index == -1) {
    for (index=0; index<TABLE_ENTRIES; index++) {
        if (table[index].lru == (TABLE_ENTRIES-1))
            break;
    }

    table[index].page_id = page_addr;
    table[index].last_cl_addr = cl_addr;
    for (int i=0; i<TABLE_ENTRIES; i++) {
        if (table[i].lru < table[index].lru)
            table[i].lru++;
    }
    table[index].lru = 0;

    return metadata_in;
  }

  // calculate the offset
  int64_t offset = 0;
  if (cl_addr > table[index].last_cl_addr)
      offset = cl_addr - table[index].last_cl_addr;
  else {
      offset = table[index].last_cl_addr - cl_addr;
      offset *= -1;
  }

  if (offset == 0)
    return metadata_in;
  
  // check hit in the observed offsets array
  int64_t prefetch_offset = 0;
  for (int i = 0; i < TRACKED_OFFSET_COUNT; i++) {
    if (table[index].tracked_offsets[i].offset == offset && table[index].tracked_offsets[i].valid == 1) {
      prefetch_offset = table[index].tracked_offsets[i].offset;
      table[index].tracked_offsets[i].frequency++;
      break;
    }
  }


  if (prefetch_offset == 0) {
    // observed offset miss, create a new entry
    for (int i = 0; i < TRACKED_OFFSET_COUNT; i++) {
      if (table[index].tracked_offsets[i].valid == 0) {
        table[index].tracked_offsets[i].offset = offset;
        table[index].tracked_offsets[i].valid = 1;
        table[index].tracked_offsets[i].frequency = 1;
        return metadata_in;
      }
    }

    // observed offset table is full, replace with offset with a least frequency
    uint64_t replacement_index = 0;
    for (int i = 1; i < TRACKED_OFFSET_COUNT; i++) {
      if (table[index].tracked_offsets[i].frequency < table[index].tracked_offsets[replacement_index].frequency) {
        replacement_index = i;
      }
    }
    table[index].tracked_offsets[replacement_index].offset = offset;
    table[index].tracked_offsets[replacement_index].valid = 1;
    table[index].tracked_offsets[replacement_index].frequency = 1;
    return metadata_in;
  }


  access_counter++;
  if (access_counter % 1024 == 0) {
    accuracy = (pf_useful - old_pf_useful)/ (double) (pf_issued - old_pf_issued);
    if ((pf_issued - old_pf_issued) > 0) {
    }

    old_pf_issued = pf_issued;
    old_pf_useful = pf_useful;
  }
  int PREFETCH_DEGREE;
  if (accuracy <= 0.20) {
    PREFETCH_DEGREE = 1;
  } else if (accuracy <= 0.30) {
    PREFETCH_DEGREE = 2;
  } else if (accuracy <= 0.35) {
    PREFETCH_DEGREE = 3;
  } else {
    PREFETCH_DEGREE = 5;
  }
  printf("PREFETCH DEGREE: %d\n", PREFETCH_DEGREE);
  for (int i=0; i<PREFETCH_DEGREE; i++) {
    uint64_t pf_address = (cl_addr + (prefetch_offset*(i+1))) << LOG2_BLOCK_SIZE;

    // check for hits in l1

    // only issue a prefetch if the prefetch address is in the same 4 KB page 
    // as the current demand access address
    if ((pf_address >> LOG2_PAGE_SIZE) != (addr >> LOG2_PAGE_SIZE))
        break;

      // check the MSHR occupancy to decide if we're going to prefetch to the L2 or LLC
    if (MSHR.occupancy < (MSHR.SIZE>>1))
      prefetch_line(ip, addr, pf_address, FILL_L2, 0);
    else
      prefetch_line(ip, addr, pf_address, FILL_LLC, 0);
  }

  table[index].last_cl_addr = cl_addr;

  for (int i=0; i<TABLE_ENTRIES; i++) {
      if (table[i].lru < table[index].lru)
          table[i].lru++;
  }
  table[index].lru = 0;

  return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t match, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{
  return metadata_in;
}

void CACHE::l2c_prefetcher_final_stats()
{

}